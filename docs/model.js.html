<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: model.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: model.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>function scriptLoaded(){
    console.log("The specific script has finished loading.");
}


class Grammar {
    variables
    terminals
    productions
    starting
    variablesIO;
    terminalsIO;
    productionsIO;
    startingIO;
    typeDisplay;

    constructor(variables, terminals, productions, starting){
        this.variables = variables;
        this.terminals = terminals;
        this.starting = starting;
        this.productions = productions;
        this.variablesIO = document.getElementById("variablesInput");
        this.terminalsIO = document.getElementById("terminalsInput");
        this.productionsIO = document.getElementById("productionsInput");
        this.startingIO = document.getElementById("startingInput");
        this.typeDisplay = document.getElementById("type");
    }

    toString(){
        return `Variables: ${this.variables} \n Terminals: ${this.terminals} \n Starting: ${this.starting} \n Productions: ${this.productions}`;
    }

    get variables(){
        return this.variables
    }
    
    get terminals(){
        return this.terminals
    }

    get productions(){
        return this.productions
    }
    get starting(){  
        return this.starting
    }

    updateOutput(){
        this.variablesIO.value = "";
        this.terminalsIO.value = "";
        this.productionsIO.value = "";
        this.startingIO.value = "";
    
        this.variablesIO.value = this.variables.join(", ");
        this.terminalsIO.value = this.terminals.join(", ");
        this.productionsIO.value = formatProductions(this.productions).join("\n");
        this.startingIO.value = this.starting;

        this.typeDisplay.textContent = "Type: " + calculateGrammarType(this);
    }
    
}

class Production {
    left;
    right;
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }

    toString() {
        return `${this.left} -> ${this.right}`; 
    } 
}

class FiniteAutomaton{
    states;
    inputAlphabet;
    transitions = [];
    generationsArray;
    observers = [];
    dfaDisplay;

    constructor(states, inputAlphabet, transitions, two){
        this.states = states
        this.inputAlphabet = inputAlphabet;

        for(let i=0; i&lt;states.length;i++){
            for(let j=0; j&lt;states.length; j++){
                var viaArray = transitions .filter(element => element.from === states[i] &amp;&amp; element.to === states[j])
                                                    .map(element => element.via)
                                                    .filter(onlyUnique);
                              
                if(viaArray.length > 0){
                    this.transitions.push(new FaTranisition(states[i], states[j], viaArray));
                }
            }
        }

        this.dfaDisplay = document.getElementById("isDFA");

        this.notfiyObservers(two);
    }

    arrangeGraph(two){
        createStatesGenerations(this.states, this.transitions);
        this.states = this.states.filter(state => state.generation != undefined);
        calculateGenerationsArray(this);
        calculateStatePositions(this); 
        this.transitions = this.transitions.filter(t => this.states.includes(t.from) &amp;&amp; this.states.includes(t.to));
    
        this.notfiyObservers(two);
    }

    clear(two){
        this.states.forEach(s => s.deleteVisuals(two));
        this.transitions.forEach(t => t.deleteVisuals(two));
        this.states = [];
        this.inputAlphabet = []; 
        this.transitions = [];
        this.generationsArray = [];
        this.notfiyObservers(two);
    }

    addState(state, two){
        this.states.push(state);
        this.notfiyObservers(two);
    }

    removeState(state, two){
        state.deleteVisuals(two);
        this.states = this.states.filter(s => s.name !== state.name);
        this.notfiyObservers(two);
    }

    moveState(state, position, two){
        state.setPosition(position.x, position.y);
        console.log(position)
        this.notfiyObservers(two);
    }

    addTransition(transition, two){
        this.transitions.push(transition);
        this.notfiyObservers(two);
    }

    markStart(state, two){
        state.isStart = true;
        this.notfiyObservers(two);
    }

    markEnd(state, two){
        state.isEnd = true;
        this.notfiyObservers(two);
    }

    removeTranstion(transition, two){
        transition.deleteVisuals(two);
        this.transitions = this.transitions.filter(t => t.index !== transition.index);
        this.notfiyObservers(two);
    }

    addObserver(observer){
        this.observers.push(observer);
    }

    notfiyObservers(two){
        this.observers.forEach(obs => obs.update(two));
    }

    updateDFADisplay(bool){
        this.dfaDisplay.textContent = bool? 'DFA' : 'NFA';
        console.log("Changed");
        
    }

}

class State{
    name;
    posX;
    posY;
    isStart;
    isEnd;
    generation;
    stateCircle;
    endCircle;
    textLabel;
    startArrow;
    index;
    subsetStates = [];

    constructor(name, isStart, isEnd, index){
        this.name = name;
        this.isStart = isStart;
        this.isEnd = isEnd;
        this.index = index;
    }

    

    setPosition(posX, posY){
        this.posX = posX;
        this.posY = posY;
        //two.update();
    }

    setGeneration(generation){
        this.generation = generation;
    }

    createVisuals(two){          

        two.remove(this.stateCircle);
        two.remove(this.endCircle);
        two.remove(this.textLabel);
        two.remove(this.startArrow);
        

        this.stateCircle = new Two.Circle(this.posX, this.posY, 100);
        this.stateCircle.fill = 'transparent';
        this.stateCircle.stroke = 'black';
        this.stateCircle.linewidth = 8;
        
        this.textLabel = new Two.Text(this.name, this.posX, this.posY);
        this.textLabel.size = 60;    

        this.endCircle = new Two.Circle(this.posX, this.posY, 85);
        this.endCircle.fill = 'transparent';
        this.endCircle.linewidth = 0;

        if(this.isEnd){
            this.endCircle.linewidth = 8;
        }

        if(this.isStart){
            this.startArrow = two.makeArrow(this.posX-200, this.posY, this.posX-100, this.posY, 40);
            this.startArrow.linewidth = 8;
        }

        two.add(this.textLabel);
        two.add(this.endCircle);
        two.add(this.stateCircle);

        two.update();


        this.stateCircle._renderer.elem.addEventListener('mousedown', () => {
            document.dispatchEvent(new CustomEvent('stateMouseDown', {detail: this}));
        });

        this.stateCircle._renderer.elem.addEventListener('mouseover', () => {

            this.stateCircle.stroke = 'green';
            this.endCircle.stroke = 'green';
            this.textLabel.fill = 'green';
            two.update();
        });

        this.stateCircle._renderer.elem.addEventListener('mouseout', () => {
            this.stateCircle.stroke = 'black'
            this.endCircle.stroke = 'black';
            this.textLabel.fill = 'black';
            two.update();
        })

        this.stateCircle._renderer.elem.addEventListener('mouseup', () => {
            document.dispatchEvent(new CustomEvent('stateMouseUp', {detail: this}));
        });

        two.update();
        
    }

    deleteVisuals(two){
        //console.log("Delete " + this.index);
        two.remove(this.stateCircle);
        two.remove(this.endCircle);
        two.remove(this.textLabel);
        two.remove(this.startArrow); 
        two.update();
    }

}

class FaTranisition{
    from;
    to;
    via = [];
    index;
    startVector;
    endVector;
    transitionLine;
    boundingBox;
    arrowhead;
    label;

    constructor(from, to, via, index){
        this.from = from;
        this.to = to;
        this.via = via;
        this.index = index;
    }

    toString(){
        return "(" + this.from.name + ", " + this.to.name + ")";
    }

    createVisuals(two, states){

        two.remove(this.transitionLine);
        two.remove(this.boundingBox);
        two.remove(this.arrowhead);
        two.remove(this.label);

    
        if (this.from == this.to){
    
            var x1 = this.from.posX + Math.cos(-Math.PI/2)*100;
            var y1 = this.from.posY + Math.sin(-Math.PI/2)*100; 
            var x2 = this.from.posX + Math.cos(-1*Math.PI/3)*200;
            var y2 = this.from.posY + Math.sin(-1*Math.PI/3)*200;
            var x3 = this.from.posX + Math.cos(-1*Math.PI/6) * 100;
            var y3 = this.from.posY + Math.sin(-1*Math.PI/6) * 100;
    
            
            this.transitionLine = two.makePath(x1, y1, x2, y2, x3, y3);
            this.transitionLine.opacity = .3;
    
            this.label = two.makeText(this.via, x2+30, y2-30);
            this.label.size = 30;
            this.label.opacity = .3    
        }
    
        else{
    
            
            var angle = Math.atan2(this.to.posY - this.from.posY, this.to.posX - this.from.posX);
            var endAngle = angle;
    
            this.startVector = {x: this.from.posX + Math.cos(angle)*100,y: this.from.posY + Math.sin(angle)*100};
            this.endVector = {x: this.to.posX - Math.cos(angle)*100, y: this.to.posY - Math.sin(angle)*100};
     
            var amount = 0;

            var pointToInsert = calculateMedianVertex(this.startVector, this.endVector);
            var normalVecor = calculateNormalVector(this.startVector, this.endVector);    
    
            for(let i=0; i&lt;states.length; i++){

                if(states[i].name === this.from.name || states[i].name === this.to.name){
                    continue;
                }
                
                var circleCenter = {x: states[i].posX, y: states[i].posY};
                
                while(amount &lt; 500 &amp;&amp; (checkLineCircleIntersection(this.startVector, pointToInsert, circleCenter, 120) || checkLineCircleIntersection(pointToInsert, this.endVector, circleCenter, 120))){
                
                    pointToInsert = movePointAlongVector(pointToInsert, normalVecor, 10);

                    angle = Math.atan2(pointToInsert.y - this.startVector.y, pointToInsert.x - this.startVector.x);
                    endAngle = Math.atan2(this.endVector.y - pointToInsert.y, this.endVector.x - pointToInsert.x);

                    this.startVector = {x: this.from.posX + Math.cos(angle)*100,y: this.from.posY + Math.sin(angle)*100};
                    this.endVector = {x: this.to.posX - Math.cos(endAngle)*100, y: this.to.posY - Math.sin(endAngle)*100};
                                        
                    amount += 1;
                }
            }

            this.transitionLine = two.makePath(this.startVector.x, this.startVector.y, pointToInsert.x, pointToInsert.y, this.endVector.x, this.endVector.y);
    
            var labelPosition = movePointAlongVector(pointToInsert, normalVecor, 30);

            this.label = two.makeText(this.via, labelPosition.x, labelPosition.y);
            this.label.size = 30;
            
            this.arrowhead = two.makePath(100, 150, 150, 10, 200, 150);
        
            this.arrowhead.fill = "black"
            this.arrowhead.scale = .3
            this.arrowhead.translation.x = this.endVector.x + Math.cos(endAngle) * -15; 
            this.arrowhead.translation.y = this.endVector.y + Math.sin(endAngle) * -15;
            this.arrowhead.rotation = endAngle + (Math.PI/2) ;
        
        }    
        
        this.transitionLine.closed = false;
        this.transitionLine.fill = "transparent"
        this.transitionLine.curved = true;
        this.transitionLine.stroke = "black"
        this.transitionLine.linewidth = 8;

        this.boundingBox = this.transitionLine.clone();
        this.boundingBox.linewidth = 40;
        this.boundingBox.noFill();
        this.boundingBox.stroke = 'transparent';

        two.add(this.boundingBox);

        for(let i=0; i&lt;states.length; i++){
            states[i].deleteVisuals(two);
            states[i].createVisuals(two);
        }

        two.update();

        this.boundingBox._renderer.elem.addEventListener('mousedown', () => {
            document.dispatchEvent(new CustomEvent('transitionMouseDown', {detail: this}));
        });

        this.boundingBox._renderer.elem.addEventListener('mouseover', () => {
            this.arrowhead.fill = 'green';
            this.label.stroke = 'green';
            this.transitionLine.stroke = 'green';
            two.update();
        });

        this.boundingBox._renderer.elem.addEventListener('mouseout', () => {
            this.arrowhead.fill = 'black';
            this.label.stroke = 'black';
            this.transitionLine.stroke = 'black';
            two.update();
        });
    }

    deleteVisuals(two){
        two.remove(this.transitionLine);
        two.remove(this.boundingBox);
        two.remove(this.arrowhead);
        two.remove(this.label);        
        two.update();
    }


}

class SentenceForm{
    form;
    previousForm;

    constructor(form, previousForm){
        this.form = form;
        this.previousForm = previousForm;
    }

    toString(){
        return this.form;
    }
}

class AutomatonObserver{
    constructor(dfa, grammar, two){
        this.dfa = dfa;
        this.grammar = grammar || {};
        this.dfa.addObserver(this);
    }

    update(two){

        var isDFA = checkAutomatonDeterminism(this.dfa);
        this.dfa.updateDFADisplay(isDFA);
        createAutomatonVisuals(two, this.dfa);
        Object.assign(this.grammar, createGrammarFromDFA(this.dfa));
        this.grammar.updateOutput();
        
    }
}

/**
 * Callback function to filter out only unique items in an array
 * @param {Int} value 
 * @param {Int} index 
 * @param {Array} array 
 * @returns whether the element is unique or not
 */
function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
  }
/**
 * Calculates the lenght of a path definded by two points
 * @param {Point} point1 
 * @param {Point} point2 
 * @returns the lenght of the paht
 */
function computeLineLength(point1, point2) {
   
    const x1 = point1.x;
    const y1 = point1.y;
    const x2 = point2.x;
    const y2 = point2.y;

    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}
/**
 * Checks if user input values represent a valid grammar
 * @param {Array} variables 
 * @param {Array} terminals 
 * @param {Array} productions 
 * @param {Array} starting 
 * @returns whether the user input is a valid grammar
 */
function checkCorrectGrammarForm(variables, terminals, productions, starting){


    if(terminals.length == 0){
        console.log("Invalid terminals")
        return false
    }

    console.log("Passed terminals check");

    for(let i=0; i&lt;productions.length; i++){
        if(!checkProduction(productions[i], variables, terminals)){
            return false
        }  
    }

    console.log("Passed productions check");

    if (!variables.includes(starting)){
        console.log("FFF");
        return false
    }


    return true;    

}

/**
 * Check if a production is valid, i.e. contains only terminals or variables
 * @param {Production} production 
 * @param {Variable} variables 
 * @param {Array} terminals 
 * @returns whether the production is valid
 */
function checkProduction(production, variables, terminals){
    var leftSide = production.left;
    var rightSide = production.right;

    console.log("Left" + leftSide + " Right: " + rightSide)

    for(let i=0; i&lt;leftSide.length;i++){

        console.log(variables[0].name === leftSide[0].name)

        if (!variables.some(element => element.name === leftSide[i].name) &amp;&amp; !terminals.some(element => element.name === leftSide[i])){
            
            return false;
            
        }
    }

    console.log("N")

    for(let i=0; i&lt;rightSide.length;i++){

        if (!variables.includes(rightSide[i]) &amp;&amp; !terminals.includes(rightSide[i]) &amp;&amp; rightSide[i] !== 'ε'){

            return false
        }
    }


    return true;
}
/**
 * Transforms valid user input into a grammar
 * @param {String} variablesInputValue 
 * @param {String} terminalsInputValue 
 * @param {String} productionsInputValue 
 * @param {String} startingInputValue 
 * @returns a new grammar based on user input
 */
function userInputToGrammar(variablesInputValue, terminalsInputValue, productionsInputValue, startingInputValue){
   
    var variables = variablesInputValue.replace(/\s/g, '').split(","); 
    var terminals = terminalsInputValue.replace(/\s/g, '').split(",");
    var starting = startingInputValue.replace(/\s/g, '');
    var productions = [];
    productionsInputValue = productionsInputValue.replace(/,/g, "");
    productionsInputValue = productionsInputValue.replace(/[ \t]/g, "");
    var splittedProductionsInput = productionsInputValue.split("\n");

    console.log(variables)


    if(terminals.length == 0){
        throw new Error("Empty terminals!");
    }

    if(!variables.includes(starting)){
        throw new Error("Invalid starting variable!")
    }

    for(let i=0; i&lt;splittedProductionsInput.length; i++){

        if(splittedProductionsInput[i] === ""){
            continue
        }

        var splittedProductionInput = splittedProductionsInput[i].split("->");
        if (splittedProductionInput.length > 2){
            return
        }
        var leftSide = splittedProductionInput[0];
        var processedLeftSide = [];

        for(let i=leftSide.length-1; i>=0; i--){
            for(let j=0; j&lt;leftSide.length; j++){
                
                var slice = leftSide.slice(i-j, i+1);
                console.log(slice)
                if(variables.some(element => element === slice)){
                    console.log("fpind")
                    processedLeftSide = [slice].concat(processedLeftSide);

                    i=i-j;
                    break;
                }
                else if(terminals.includes(slice)){
                    processedLeftSide = [slice].concat(processedLeftSide);
                    i=i-j;
                    break;
                }
                else{
                    console.log("Not found");
                }
            }
        }
        console.log(processedLeftSide)

        var rightSides = splittedProductionInput[1].split("|");
        
        
        for(let j=0; j&lt;rightSides.length; j++){
            var rightSide = rightSides[j];
            var processedRightSide = [];

            for(let i=rightSide.length-1; i>=0; i--){
                for(let j=0; j&lt;rightSide.length; j++){
                    
                    var slice = rightSide.slice(i-j, i+1);

                    if(variables.some(element => element === slice)){

                        processedRightSide = [slice].concat(processedRightSide);

                        i=i-j;
                        break;
                    }
                    else if(terminals.includes(slice) || slice === 'ε'){
                        processedRightSide = [slice].concat(processedRightSide);
                        i=i-j;
                        break;
                    }
                    else{
                        console.log("Not found");
                    }
                }
            }

            productions.push(new Production(processedLeftSide, processedRightSide));

        }
    }
    console.log(productions)
    return new Grammar(variables, terminals, productions, starting)
}
/**
 * Calculates the middle point of a path defined by two points
 * @param {Point} point1 
 * @param {Point} point2 
 * @returns the middle point
 */
function calculateMedianVertex(point1, point2){
    return {x: (point2.x+point1.x)/2, y: (point2.y+point1.y)/2}

    
}

/**
 * Creates visuals for the states and transitions of an automaton
 * @param {Two} two 
 * @param {FiniteAutomaton} automaton 
 */
function createAutomatonVisuals(two, automaton){
    two.clear();
    automaton.states.forEach(state => state.createVisuals(two));
    automaton.transitions.forEach(transition => transition.createVisuals(two, automaton.states));
}
/**
 * Finds the successor state(s) for a given state
 * @param {Array[]} faTransitions 
 * @param {State} state 
 * @returns the successor states
 */
function calculateStateSuccessors(faTransitions, state){
    var successors = [];
    for(let i=0; i&lt;faTransitions.length; i++){
        if(faTransitions[i].from === state &amp;&amp; faTransitions[i].to !== state){
            successors.push(faTransitions[i].to);
        }

    }
    return successors;
}
/**
 * Finds the predecessor state(s) for a given state
 * @param {Array} faTransitions 
 * @param {State} state 
 * @returns the predecessor states
 */
function calculateStatePredecessors(faTransitions, state){
    return Array.from(new Set((faTransitions.filter(trans => trans.to === state &amp;&amp; trans.from !== state).map(t => t.from))));
}
/**
 * Assigns each state the number of steps needed to reach that state from the start state (BFS)
 * @param {Array} states 
 * @param {Array} transitions 
 */
function createStatesGenerations(states, transitions){
    var visited = new Set();
    var statesToVisit = [];
    var startStates = states.filter(state => state.isStart);

    for(const startState of startStates){
        startState.generation = 0;
        statesToVisit.push(startState);
        visited.add(startState);

        while(statesToVisit.length != 0){
            var currentState = statesToVisit.shift();
            var successors = calculateStateSuccessors(transitions, currentState);
            for(const successor of successors){
                if(!visited.has(successor)){
                    successor.generation = currentState.generation + 1;
                    statesToVisit.push(successor);
                    visited.add(successor);
                }
                else {
                    break;
                    
                }
            }
        }
    }
}
/**
 * Calculates the state positions based on their generation value
 * @param {FiniteAutomaton} automaton 
 */
function calculateStatePositions(automaton){
    
    for(let i=0; i&lt;automaton.generationsArray.length; i++){
        
        for(let j=0; j&lt;automaton.generationsArray[i].length; j++){
            automaton.generationsArray[i][j].posY = 400 + (300 * j) 
            automaton.generationsArray[i][j].posX = 200 + 300 * i;
        }
    }

}
/**
 * Creates an 2D-Array that stores the count of states in each generation for layout generation
 * @param {FiniteAutomaton} automaton 
 */
function calculateGenerationsArray(automaton){
    var states = automaton.states;

    let maxGeneration = 0;

    states.forEach(state => {
        if (state.generation != undefined &amp;&amp; state.generation > maxGeneration) {
            maxGeneration = state.generation;
        }
    });
    
    automaton.generationsArray = [];

    for(let i=0; i&lt;=maxGeneration; i++){
        automaton.generationsArray[i] = [];
    }


    for(let i=0; i&lt;states.length; i++){
        var stateGeneration = states[i].generation;
        if(stateGeneration != undefined){
            automaton.generationsArray[stateGeneration].push(states[i]);

        }
    }

    console.log(automaton.generationsArray);

}
/**
 * Checks if the path of transition intersects with the circle of any state
 * @param {Two} two 
 * @param {FaTranisition} transition 
 * @param {Array} states 
 * @returns whether path and state circles intersect
 */
function checkTransitionStatesIntersection(two, transition, states) {

    
    var arrowStartCoords = transition.startVector;
    var arrowEndCoords = transition.endVector;


    
    var transitionLength = computeLineLength(arrowStartCoords, arrowEndCoords);
    var fromVector = {x: transition.from.posX, y: transition.from.posY};
    var toVector = {x: transition.to.posX, y: transition.to.posY};

    var distanceBetweenStates = computeLineLength(fromVector, toVector); 


    if(transitionLength + 200 &lt; distanceBetweenStates){
        
        return false;
    }




    
    for(let i=0; i&lt;states.length; i++){
        var circleCenterCoords = {x: states[i].posX, y: states[i].posY};
        var circleRadius = 100;
        if(checkLineAndCircleIntersection(arrowStartCoords, arrowEndCoords, circleCenterCoords, circleRadius)){
            console.log("Intersecting: ");
            console.log(transition.toString());
            return true;
        }
        else{
            return false;
        }
    }

}
/**
 * Checks if a path given by two points intersects with a circle given by center and radius
 * @param {Point} lineStart 
 * @param {Point} lineEnd 
 * @param {Point} circleCenter 
 * @param {Int} circleRadius 
 * @returns whether path and circle intersect
 */
function checkLineCircleIntersection(lineStart, lineEnd, circleCenter, circleRadius){
    const startToCenterVector = { x: circleCenter.x - lineStart.x, y: circleCenter.y - lineStart.y };

    // Calculate vector from line start to line end
    const startToEndVector = { x: lineEnd.x - lineStart.x, y: lineEnd.y - lineStart.y };

    // Calculate squared length of line segment
    const lineLengthSquared = startToEndVector.x * startToEndVector.x + startToEndVector.y * startToEndVector.y;

    // Calculate dot product of startToCenterVector and startToEndVector
    const dotProduct = startToCenterVector.x * startToEndVector.x + startToCenterVector.y * startToEndVector.y;

    let closestPointOnLine;

    // Check if the line segment is degenerate (length is zero)
    if (lineLengthSquared === 0) {
        // If the line segment is a single point, use that point as the closest point
        closestPointOnLine = lineStart;
    } else {
        // Calculate the parameter t for the closest point on the line
        const t = Math.max(0, Math.min(1, dotProduct / lineLengthSquared));

        // Calculate the coordinates of the closest point on the line segment
        closestPointOnLine = {
            x: lineStart.x + t * startToEndVector.x,
            y: lineStart.y + t * startToEndVector.y
        };
    }

    // Calculate the distance between the closest point and the circle center
    const distanceToClosestPointSquared = Math.pow(circleCenter.x - closestPointOnLine.x, 2) + Math.pow(circleCenter.y - closestPointOnLine.y, 2);

    // Check if the distance is less than or equal to the square of the circle radius
    return distanceToClosestPointSquared &lt;= circleRadius * circleRadius;
}
/**
 * Converts a grammar into a NFA
 * @param {Grammar} grammar 
 * @param {Two} two 
 * @returns a NFA
 */
function createNFAFromGrammar(grammar, two){
    
    var variables = grammar.variables;
    var starting = grammar.starting;
    var inputAlphabet = grammar.terminals;
    var productions = grammar.productions;

    var states = []
    var transitions = []

    var transitionIndex = 0;


    for(let i=0; i&lt;variables.length; i++){
        states.push(new State(variables[i], false, false, i));
    }

    console.log(starting)

    var startingState = states.find(element => element.name === starting);
    if (startingState) {
        startingState.isStart = true;
    }

    for(let i=0; i&lt;variables.length; i++){
        for(let j=0; j&lt;inputAlphabet.length; j++){
    
            for(let k=0; k&lt;productions.length; k++){

                console.log([variables[i]])
                if(productions[k].right.length === 2 &amp;&amp;
                   productions[k].left.join("") === variables[i] &amp;&amp;
                   productions[k].right[0] === inputAlphabet[j]){
                    console.log("AAA")
                    let b = productions[k].right[1];
                    let stateB = states.find(element => element.name === b);
                    let stateI = states.find(element => element.name === variables[i]);
                    transitions.push(new FaTranisition(stateI, stateB, inputAlphabet[j], transitionIndex));
                    transitionIndex++;
                }
            }
    
            let productionToCheck = productions.find(element => (element.left.join("") === variables[i] &amp;&amp; element.right.join("") === inputAlphabet[j]));
            if(productionToCheck != undefined){
                states.push(new State("Ze", false, true));
                let stateI = states.find(element => element.name === variables[i]);
                let zeState = states.find(element => element.name === "Ze");
                transitions.push(new FaTranisition(stateI, zeState, inputAlphabet[j], transitionIndex));
                transitionIndex++;
            }
        }
        console.log(transitions)
    }
    

    if(productions.some(element => (element.left.join("") === starting &amp;&amp; element.right.join("") === "ε"))){

        states.find(element => element.name === starting).isEnd = true;
    
    }

    //console.log(calculateStatePredecessor(transitions, zeState));

    var automaton = new FiniteAutomaton(states, inputAlphabet, transitions, two);
    

    return automaton;
}
/**
 * Calculates the grammar type (from 0-3)
 * @param {Grammar} grammar 
 * @returns the grammar type
 */
function calculateGrammarType(grammar){
    
    var productions = grammar.productions;
    var variables = grammar.variables;
    var terminals = grammar.terminals.slice();
    terminals.push("ε");

    var isType1 = true;
    var isType2 = true;
    var isType3 = true;

    for(let i=0; i&lt;productions.length; i++){
        
        isType1 &amp;= (productions[i].left.length &lt;= productions[i].right.length);
        isType2 &amp;= (isType1 &amp;&amp; variables.includes(productions[i].left.join("")));
        isType3 &amp;= (isType2 &amp;&amp; productions[i].right.length &lt;= 2 &amp;&amp; (terminals.includes(productions[i].right[0]) &amp;&amp; (terminals.includes(productions[i].right.slice(-1).join("")) ||variables.includes(productions[i].right.slice(-1).join("")))));
    }

    if(isType3){
        return 3
    }
    if(isType2){
        return 2
    }
    if(isType1){
        return 1
    }

    return 0

}
/**
 * Converts a DFA into a grammar
 * @param {FiniteAutomaton} automaton 
 * @returns a Grammar
 */
function createGrammarFromDFA(automaton){
    console.log(automaton)
    var variables = [];
    var terminals;
    var productions = [];
    var starting;

    for(i=0; i&lt;automaton.states.length; i++){
        variables.push(automaton.states[i].name);
    }

    var startState = automaton.states.find(element => element.isStart === true);

    if(startState != undefined){
        starting = startState.name;

        if(startState.isEnd){
            console.log("FFF")
            productions.push(new Production(startState.name, "ε"));
            console.log(startState.isEnd)
        }
    }

    

    

    terminals = automaton.inputAlphabet;

    for(let i=0; i&lt;automaton.states.length; i++){
        for(let j=0; j&lt;automaton.inputAlphabet.length; j++){
            console.log("AAA")
            var successor = calculateStateSuccessorVia(automaton.transitions, automaton.states[i], automaton.inputAlphabet[j]);
            if(successor != undefined){

                productions.push(new Production(automaton.states[i].name, automaton.inputAlphabet[j] + successor.name));
            
                if(successor.isEnd){
                    productions.push(new Production(automaton.states[i].name, automaton.inputAlphabet[j]));
                }
            }
        }
    }

    return new Grammar(variables, terminals, productions, starting);
}
/**
 * Finds one successor of a given state using the given terminal symbol
 * @param {Array} transitions 
 * @param {State} state 
 * @param {String} via 
 * @returns the successor
 */
function calculateStateSuccessorVia(transitions, state, via){

    var successorTransition = transitions.find(element => element.from === state &amp;&amp; element.via.includes(via));

    if(successorTransition != undefined){
        return successorTransition.to
    }

}
/**
 * Finds the successors of a given state using the given terminal symbol
 * @param {Array} transitions 
 * @param {State} state 
 * @param {String} via 
 * @returns the successors
 */
function calculateStateSuccessorsVia(transitions, state, via){

    return transitions.filter(element => element.from === state &amp;&amp; element.via.includes(via)).map(e => e.to);

}
/**
 * Formats an array of productions in a readable way
 * @param {Array} productions 
 * @returns the formatted productions
 */
function formatProductions(productions) {
    var groupedProductions = {};

    productions.forEach(production => {
        if (!groupedProductions[production.left]) {
            groupedProductions[production.left] = [];
        }
        groupedProductions[production.left].push(production.right);
    });

    var formattedProductions = [];
    for (var left in groupedProductions) {
        formattedProductions.push(left + " -> " + groupedProductions[left].join(" | "));
    }

    return formattedProductions;
}
/**
 * Makes a screenshot of the graph and saves it locally
 */
function makeDrawingAreaScreenshot(){
}
/**
 * Checks if the given word contains only the given terminals
 * @param {Array} terminals 
 * @param {String} word 
 * @returns 
 */
function checkWordAlphabet(terminals, word){
    
    var wordIsOverAlphabet = true;
    
    for(let i=0; i&lt;word.length; i++){
        wordIsOverAlphabet &amp;= (terminals.includes(word[i]));
    }

    return wordIsOverAlphabet;
}
/**
 * Checks if the grammar can create the given word
 * @param {Grammar} grammar 
 * @param {String} word 
 * @returns 
 */
function decideWordProblem(grammar, word){



    if(!checkWordAlphabet(grammar.terminals, word)){
        return undefined;
    }

    var n = word.length;
    var l = [new SentenceForm(grammar.starting, null)];
    var lOld;
    var i=0;

    do {
        lOld = l;
        l = next(lOld, n, grammar.productions);
        i++;

    }
    while(i&lt;50 &amp;&amp; !(l.some(element => element.form === word) || checkArrayEuquality(l, lOld)));
    
    return (l.find(element => element.form === word));
}
/**
 * Helper function that calculate the derivations of all current sentence forms
 * @param {SentenceForm} l the set of sentence forms
 * @param {SentenceForm} n the max lenght of sentence forms allowed
 * @param {Array} productions 
 * @returns 
 */
function next(l, n, productions){

    var successorDerivations = l.slice();

    for(let i=0; i&lt;l.length; i++){

        var successorDerivation = calculateOneStepDerivations(l[i], n, productions);
        
        successorDerivations = successorDerivations.concat(successorDerivation)
            
    }

    return successorDerivations.filter(filterOutUniqueForms);
    
}
/**
 * Calculates the successor sentence forms by applying all valid productions to the given sentence form
 * @param {SentenceForm} sentenceForm 
 * @param {Int} maxLenght 
 * @param {Array} productions 
 * @returns the successor sentence forms
 */
function calculateOneStepDerivations(sentenceForm, maxLenght, productions){
    
    var derivations = [];
    
    for(let i=0; i&lt;sentenceForm.form.length; i++){
        for(let j=0; j&lt;sentenceForm.form.length; j++){

            var firstPortion = sentenceForm.form.slice(0, i);

            var currentPortion = sentenceForm.form.slice(i, j+1);

            var lastPortion = sentenceForm.form.slice(j+1, sentenceForm.length); //possible error

            var matchingProductions = productions.filter(element => element.left.join("") === currentPortion);


            if(matchingProductions != undefined){
                for(let k=0; k&lt;matchingProductions.length; k++){

                    resultingSentenceForm = (firstPortion + matchingProductions[k].right + lastPortion.replace(/ε/g, ''));

                    if(resultingSentenceForm.split(",").length &lt;= maxLenght &amp;&amp; resultingSentenceForm.split(",").length > 0){
                        derivations.push(new SentenceForm(firstPortion + matchingProductions[k].right.join("") + lastPortion.replace(/ε/g, ''), sentenceForm))
                    }
                }
            }
        }
    }

    return derivations;
}
/**
 * Checks if two arrays contains exactly the same elements
 * @param {Array} array1 
 * @param {Array2} array2 
 * @returns whether two arrays elements are equal
 */
function checkArrayEuquality(array1, array2){
    if(array1.length !== array2.length){
        return false;
    }

    var array1Sorted = array1.slice().sort();
    var array2Sorted = array2.slice().sort();

    for(let i=0; i&lt;array1Sorted.length; i++){
        if(array1Sorted[i] !== array2Sorted[i]){
            return false;
        }
    }
    return true;
}
/**
 * Checks if two arrays share at least one element
 * @param {Array} array1 
 * @param {Array} array2 
 * @returns 
 */
function checkArrayIntersection(array1, array2){
    var size = Math.min(array1.length, array2.length);
    for(let i=0; i&lt;size; i++){
        if(array1.includes(array2[i])){
            return true
        }
    }
    return false
}
/**
 * Converts the trace of predecessor forms into a string
 * @param {SentenceForm} sentenceForm 
 * @returns the string representation of the trace
 */
function sentenceFormPredecessorsToString(sentenceForm){
    
    var predecessors = [];
    var temp = sentenceForm;
    var outputString;
    
    while(temp != null){
        predecessors.push(temp.form);
        temp = temp.previousForm;
    }

    predecessors.reverse();
    outputString = predecessors.join(" -> ");

    return outputString;
}
/**
 * Filters out the unique sentence forms (by value, not reference)
 * @param {any} value 
 * @param {Int} index 
 * @param {any} self 
 * @returns the filtered array
 */
const filterOutUniqueForms = (value, index, self) => {
    return self.findIndex(obj => obj.form === value.form) === index;
};
/**
 * Generates example words that can be created by the grammar
 * @param {Grammar} grammar 
 * @param {Int} maxCount 
 * @returns example words
 */
function generateTerminalsForms(grammar, maxCount){

    var n = 7;
    var l = [new SentenceForm(grammar.starting, null)];
    console.log(l.length)
    var lOld;
    var i=0;

    do {
        lOld = l;
        l = next(lOld, n, grammar.productions);
        i++;

    }
    while(i&lt;6 &amp;&amp; !checkArrayEuquality(l, lOld));

    l = l.filter(element => checkWordAlphabet(grammar.terminals, element.form))

    l = l.slice(0, maxCount);

    var stringOutput = l.join(", ");
    
    return stringOutput;


}
/**
 * Saves the user input in the browser's session storage
 * @param {Array} variables 
 * @param {Array} terminals 
 * @param {Array} productions 
 * @param {Array} starting 
 */
function grammarformToSessionStorage(variables, terminals, productions, starting){
    sessionStorage.setItem("variables", variables);
    sessionStorage.setItem("terminals", terminals);
    sessionStorage.setItem("productions", productions);
    sessionStorage.setItem("starting", starting);
}
/**
 * Creates a number in subscript
 * @param {Int} number 
 * @returns the number in subscript
 */
function numberToSubscript(number){
    var input = number.toString();
    var output = "";

    for(let i=0; i&lt;input.length; i++){
        output += String.fromCharCode(input.charCodeAt(i) + 8272);
    }

    return output
}
/**
 * Converts a NFA into a DFA
 * @param {FiniteAutomaton} automaton 
 * @param {Two} two 
 * @returns a deterministic automaton
 */
function NFAToDFA(automaton, two){

    var dfaStates = createPowerSetOfStates(automaton.states);
    
    dfaStates.find(element => checkArrayEuquality(element.subsetStates, automaton.states.filter(state => state.isStart))).isStart = true;

    dfaStates.filter(element => checkArrayIntersection(element.subsetStates.map(state => state.name), automaton.states.filter(state => state.isEnd == true).map(e => e.name))).forEach(state => state.isEnd = true);

    var dfaTransitions = [];

    var transitionIndex = 0;


    for(let i=0; i&lt;dfaStates.length; i++){
        var state = dfaStates[i];
        for(let j=0; j&lt;automaton.inputAlphabet.length; j++){
            var successorStates = new Set();
            for(let k=0; k&lt;state.subsetStates.length; k++){
                var subsetSuccessors = calculateStateSuccessorsVia(automaton.transitions, state.subsetStates[k], automaton.inputAlphabet[j]);
                
                
                subsetSuccessors.forEach(successor => successorStates.add(successor));
            }

            var matchingSubsetState = dfaStates.find(s => checkArrayEuquality(s.subsetStates.map(e => e.name), Array.from(successorStates).map(t => t.name)));
            console.log(matchingSubsetState)
            if(matchingSubsetState != undefined){
                dfaTransitions.push(new FaTranisition(state, matchingSubsetState, automaton.inputAlphabet[j], transitionIndex));
                transitionIndex++;
            }
        }
    }

    return new FiniteAutomaton(dfaStates, automaton.inputAlphabet, dfaTransitions, two);


}
/**
 * Calculates the normalized normal vector of a path given by two points
 * @param {Point} point1 
 * @param {Point} point2 
 * @returns the normalized normal vector
 */
function calculateNormalVector(point1, point2){
    var dx = point2.x - point1.x;
    var dy = point2.y - point1.y;
    var normalVecor = {x: -dy, y: dx};
    var length = Math.sqrt(normalVecor.x * normalVecor.x + normalVecor.y * normalVecor.y);

    return {x: normalVecor.x / length, y: normalVecor.y / length};
}
/**
 * Moves a point along the given vector by the given distance
 * @param {Point} point 
 * @param {Point} vector 
 * @param {Int} distance 
 * @returns the moved point
 */
function movePointAlongVector(point, vector, distance){
    return {x: point.x + vector.x * distance, y: point.y + vector.y * distance};
}
/**
 * Creates the power set of states (excluding the empty set)
 * @param {Array} states 
 * @returns the power set of states
 */
function createPowerSetOfStates(states){
    var subsets = [];
    var currentSubset = [];
    var outputStates = [];
    function depthFirstSearch(index){
        if(index === states.length){

            subsets.push([...currentSubset])
            return
            
        }
        currentSubset.push(states[index]);
        depthFirstSearch(index+1);
        currentSubset.pop();
        depthFirstSearch(index+1);
    }
    depthFirstSearch(0);
    subsets.pop();
    for(let i=0; i&lt;subsets.length; i++){
        var subsetStates = []
        for(let j=0; j&lt;subsets[i].length; j++){
            subsetStates.push(subsets[i][j]);
        }
        var state = new State('{' + subsetStates.map(state => state.name).join("") + '}', false, false, i)
        state.subsetStates = subsetStates;
        outputStates.push(state);
    }
    return outputStates
}
/**
 * Checks if the given automaton is DFA or NFA
 * @param {FiniteAutomaton} automaton 
 * @returns whether the automaton is DFA or NFA
 */
function checkAutomatonDeterminism(automaton){

    if(automaton.states.filter(state => state.isStart).length > 1){
        return false;
    }
    for(let i=0; i&lt;automaton.states.length; i++){
        for(let j=0; j&lt;automaton.inputAlphabet.length; j++){
            if(calculateStateSuccessorsVia(automaton.transitions, automaton.states[i], automaton.inputAlphabet[j]).length > 1){
                return false;
            }
        }
    }
    return true;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#NFAToDFA">NFAToDFA</a></li><li><a href="global.html#calculateGenerationsArray">calculateGenerationsArray</a></li><li><a href="global.html#calculateGrammarType">calculateGrammarType</a></li><li><a href="global.html#calculateMedianVertex">calculateMedianVertex</a></li><li><a href="global.html#calculateNormalVector">calculateNormalVector</a></li><li><a href="global.html#calculateOneStepDerivations">calculateOneStepDerivations</a></li><li><a href="global.html#calculateStatePositions">calculateStatePositions</a></li><li><a href="global.html#calculateStatePredecessors">calculateStatePredecessors</a></li><li><a href="global.html#calculateStateSuccessorVia">calculateStateSuccessorVia</a></li><li><a href="global.html#calculateStateSuccessors">calculateStateSuccessors</a></li><li><a href="global.html#calculateStateSuccessorsVia">calculateStateSuccessorsVia</a></li><li><a href="global.html#checkArrayEuquality">checkArrayEuquality</a></li><li><a href="global.html#checkArrayIntersection">checkArrayIntersection</a></li><li><a href="global.html#checkAutomatonDeterminism">checkAutomatonDeterminism</a></li><li><a href="global.html#checkCorrectGrammarForm">checkCorrectGrammarForm</a></li><li><a href="global.html#checkLineCircleIntersection">checkLineCircleIntersection</a></li><li><a href="global.html#checkProduction">checkProduction</a></li><li><a href="global.html#checkTransitionStatesIntersection">checkTransitionStatesIntersection</a></li><li><a href="global.html#checkWordAlphabet">checkWordAlphabet</a></li><li><a href="global.html#computeLineLength">computeLineLength</a></li><li><a href="global.html#createAutomatonVisuals">createAutomatonVisuals</a></li><li><a href="global.html#createGrammarFromDFA">createGrammarFromDFA</a></li><li><a href="global.html#createNFAFromGrammar">createNFAFromGrammar</a></li><li><a href="global.html#createPowerSetOfStates">createPowerSetOfStates</a></li><li><a href="global.html#createStatesGenerations">createStatesGenerations</a></li><li><a href="global.html#decideWordProblem">decideWordProblem</a></li><li><a href="global.html#filterOutUniqueForms">filterOutUniqueForms</a></li><li><a href="global.html#formatProductions">formatProductions</a></li><li><a href="global.html#generateTerminalsForms">generateTerminalsForms</a></li><li><a href="global.html#grammarformToSessionStorage">grammarformToSessionStorage</a></li><li><a href="global.html#makeDrawingAreaScreenshot">makeDrawingAreaScreenshot</a></li><li><a href="global.html#movePointAlongVector">movePointAlongVector</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#numberToSubscript">numberToSubscript</a></li><li><a href="global.html#onlyUnique">onlyUnique</a></li><li><a href="global.html#sentenceFormPredecessorsToString">sentenceFormPredecessorsToString</a></li><li><a href="global.html#userInputToGrammar">userInputToGrammar</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Feb 22 2024 13:51:20 GMT+0100 (Mitteleuropäische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
